Харківський національний університет радіоелектроніки
Факультет комп’ютерних наук
Катедра програмної інженерії




ЗВІТ
з лабораторної роботи №2
з дисципліни «Архітектура програмного забезпечення»
на тему: «РОЗРОБКА СЕРВЕРНОЇ ЧАСТИНИ СИСТЕМИ»




Виконав
ст. гр. ПЗПІ-22-3
Шпак Денис Олександрович


Перевірив
ст. викладач катедри ПІ
Сокорчук Ігор Петрович







Харків 2025
1 ІСТОРІЯ ЗМІН

№	Дата	Версія звіту	Опис змін та виправлень
1	14.04.2025	0.1	Створено розділ «Завдання»
2	18.04.2025	0.1	Створено розділ «Опис виконаної роботи»
3	20.04.2025	0.1	Наповнено додатки А та Б
4	25.04.2025	0.1	Підбито висновки роботи
5	28.04.2025	0.1	Заповнено додаток В з програмним кодом

2 ЗАВДАННЯ

Метою даного лабораторного заняття є втілення функцій бізнес логіки та функцій адміністрування системи.

3 ОПИС ВИКОНАНОЇ РОБОТИ

До виконаної роботи було створено відеозвіт, посилання на який наведено у додатку А.
Спочатку було вирішено використовувати лінійну регресію для алгоритму, що вирішить проблему вибору оптимального маршруту для постачання продукції з урахуванням довжини шляху, швидкості повітня, температури, вологості. Таким чином, діаграми, що наводять принципи роботи системи з таким алгоритмом наведено у додатку Б.
 Слід зазначити, що для розрахунку довжини маршруту використовувалася спеціальна формула. Код, що використовувався для втілення функцій у програмну систему наведено у додатку В.
Також було втілено функції адміністрування. Такі функції було створено для адміністратора системи вцілому, для адміністратора платформи, та локального адміністратора, прикріплено для новоствореної компанії, а також для адміністратора баз даних.
Для функцій адміністратора системи було передбачено такі функції: переглянути стан системи, отримати конфігурації системи, змінити конфігурації системи, отримати журнал логів, очистити журнал логів.
Для функцій адміністратора платформи втілено наступний функціонал: зміна ролей користувачам, додавання користувачів до компаній, їх видалення звідти, зміна ролей користувачів у компанії.
Для функцій адміністратора баз даних було додано функції: створення резервної копії бази даних, відновлення бази даних з резервної копії, отримання стану бази дених, оптимізація бази даних.
ВИСНОВКИ

У результаті виконання даної лабораторної роботи було втілено функції бізнес логіки з використанням математичних методів, а також втілено функції адміністрування програмної системи.

ДОДАТОК А
Відеозапис

Відеозапис презентації результатів лабораторної роботи: https://youtu.be/Zf1UATryUuQ

Хронологічний опис відеозапису:
00:00 Вітання. Доповідач вітається, розповідає про те, яку роботу було виконано у результаті виконання лабораторної роботи.
00:32 Функції бізнес логіки. Використання лінійної регресії. Розглянуто функціонал розрахунку оптимального маршруту для постачання з урахуванням даних про вологість, швидкість повітря, перевозиму вагу. Розглядаються функції написані для розрахунку рівняння лінійної регресії.
03:11 Функції адміністратора платформи. Розглядається функціонал зміни ролей користувачів, функціонал додавання користувачів до створених компаній, видалення їх звідти, та зміни їх ролі там.
05:18 Функції адміністратора системи. Розглядається функціонал перевірки стану системи, отримання та очещення системних логів, отримання та зміни системних налаштувань.
07:26 Функції адміністратора баз даних. Розглядається функціонал створення резервних копій бази даних та відновлення бази даних з резервних копій. Функціонал перевірки стану бази даних та її оптимізації командою VACUUM FULL.
09:19 Висновки. Підбиття підсумків, короткий опис виконаної роботи.
ДОДАТОК Б
Графічні матеріали

 
Рисунок Б.1 – ER-діаграма даних

Рисунок Б.2 — Структура бази даних

Рисунок Б.3 — UML-діаграма прецедентів


ДОДАТОК В
Програмний код

В.1 Математична обробка прикладних даних. Допоміжні математичні операції.

GitHub репозиторій: https://github.com/NureShpakDenys/apz-pzpi-22-3-shpak-denys/blob/main/Lab2/pzpi-22-3-shpak-denys-lab2/internal/core/domain/utils/math/math.go

  1  // Package math provides mathematical functions for the domain layer.
  2  // This package is used to perform mathematical operations on data.
  3  package math // import "wayra/internal/core/domain/utils/math"
  4  
  5  import "math"
  6  
  7  // Transpose returns the transpose of a matrix.
  8  // matrix: a 2D slice of float64.
  9  // returns: a 2D slice of float64.
 10  func Transpose(matrix [][]float64) [][]float64 {
 11  	rows := len(matrix)
 12  	cols := len(matrix[0])
 13  	result := make([][]float64, cols)
 14  	for i := range result {
 15  		result[i] = make([]float64, rows)
 16  	}
 17  	for i := 0; i < rows; i++ {
 18  		for j := 0; j < cols; j++ {
 19  			result[j][i] = matrix[i][j]
 20  		}
 21  	}
 22  	return result
 23  }
 24  
 25  // MultiplyMatrices returns the product of two matrices.
 26  // a: a 2D slice of float64.
 27  // b: a 2D slice of float64.
 28  // returns: a 2D slice of float64.
 29  func MultiplyMatrices(a, b [][]float64) [][]float64 {
 30  	rowsA := len(a)
 31  	colsA := len(a[0])
 32  	colsB := len(b[0])
 33  	result := make([][]float64, rowsA)
 34  	for i := range result {
 35  		result[i] = make([]float64, colsB)
 36  	}
 37  	for i := 0; i < rowsA; i++ {
 38  		for j := 0; j < colsB; j++ {
 39  			for k := 0; k < colsA; k++ {
 40  				result[i][j] += a[i][k] * b[k][j]
 41  			}
 42  		}
 43  	}
 44  	return result
 45  }
 46  
 47  // Inverse returns the inverse of a matrix.
 48  // matrix: a 2D slice of float64.
 49  // returns: a 2D slice of float64.
 50  func Inverse(matrix [][]float64) [][]float64 {
 51  
 52  	n := len(matrix)
 53  	augmented := make([][]float64, n)
 54  	for i := range augmented {
 55  		augmented[i] = make([]float64, 2*n)
 56  		copy(augmented[i], matrix[i])
 57  		augmented[i][n+i] = 1
 58  	}
 59  
 60  	for i := 0; i < n; i++ {
 61  
 62  		maxRow := i
 63  		for j := i + 1; j < n; j++ {
 64  			if math.Abs(augmented[j][i]) > math.Abs(augmented[maxRow][i]) {
 65  				maxRow = j
 66  			}
 67  		}
 68  
 69  		augmented[i], augmented[maxRow] = augmented[maxRow], augmented[i]
 70  
 71  		pivot := augmented[i][i]
 72  		for j := 0; j < 2*n; j++ {
 73  			augmented[i][j] /= pivot
 74  		}
 75  
 76  		for j := i + 1; j < n; j++ {
 77  			factor := augmented[j][i]
 78  			for k := 0; k < 2*n; k++ {
 79  				augmented[j][k] -= factor * augmented[i][k]
 80  			}
 81  		}
 82  	}
 83  
 84  	for i := n - 1; i >= 0; i-- {
 85  		for j := i - 1; j >= 0; j-- {
 86  			factor := augmented[j][i]
 87  			for k := 0; k < 2*n; k++ {
 88  				augmented[j][k] -= factor * augmented[i][k]
 89  			}
 90  		}
 91  	}
 92  
 93  	inverse := make([][]float64, n)
 94  	for i := range inverse {
 95  		inverse[i] = make([]float64, n)
 96  		copy(inverse[i], augmented[i][n:])
 97  	}
 98  
 99  	return inverse
100  }
101  
102  // HaversineDistance returns the distance between two points on the Earth's surface.
103  // lat1: latitude of the first point.
104  // lon1: longitude of the first point.
105  // lat2: latitude of the second point.
106  // lon2: longitude of the second point.
107  // returns: a float64 - the distance between the two points.
108  func HaversineDistance(lat1, lon1, lat2, lon2 float64) float64 {
109  	const R = 6371
110  	lat1Rad := lat1 * math.Pi / 180
111  	lon1Rad := lon1 * math.Pi / 180
112  	lat2Rad := lat2 * math.Pi / 180
113  	lon2Rad := lon2 * math.Pi / 180
114  	dLat := lat2Rad - lat1Rad
115  	dLon := lon2Rad - lon1Rad
116  
117  	a := math.Sin(dLat/2)*math.Sin(dLat/2) + math.Cos(lat1Rad)*math.Cos(lat2Rad)*math.Sin(dLon/2)*math.Sin(dLon/2)
118  	c := 2 * math.Atan2(math.Sqrt(a), math.Sqrt(1-a))
119  
120  	return R * c
121  }
122  
123  // Mean returns the mean of a slice of float64.
124  // data: a slice of float64.
125  // returns: a float64 - the mean of the data.
126  func Mean(data []float64) float64 {
127  	sum := 0.0
128  	for _, value := range data {
129  		sum += value
130  	}
131  	return sum / float64(len(data))
132  }
133  
134  // StdDev returns the standard deviation of a slice of float64.
135  // data: a slice of float64.
136  // returns: a float64 - the standard deviation of the data.
137  func StdDev(data []float64) float64 {
138  	mean := Mean(data)
139  	sumSquares := 0.0
140  	for _, value := range data {
141  		diff := value - mean
142  		sumSquares += diff * diff
143  	}
144  	variance := sumSquares / float64(len(data))
145  	return math.Sqrt(variance)
146  }
147  
148  // Square returns the square of each element in a slice of float64.
149  // data: a slice of float64.
150  // returns: a slice of float64.
151  func Square(data []float64) []float64 {
152  	result := make([]float64, len(data))
153  	for i, value := range data {
154  		result[i] = value * value
155  	}
156  	return result
157  }
158  
159  // Multiply returns the element-wise product of two slices of float64.
160  // a: a slice of float64.
161  // b: a slice of float64.
162  // returns: a slice of float64.
163  func Multiply(a, b []float64) []float64 {
164  	result := make([]float64, len(a))
165  	for i := range result {
166  		result[i] = a[i] * b[i]
167  	}
168  	return result
169  }
170  
171  // Sum returns the sum of a slice of float64.
172  // data: a slice of float64.
173  // returns: a float64 - the sum of the data.
174  func Sum(data []float64) float64 {
175  	sum := 0.0
176  	for _, value := range data {
177  		sum += value
178  	}
179  	return sum
180  }

В.2 Математична обробка прикладних даних. Код розрахунку рівняння лінійної регресії.

GitHub репозиторій: https://github.com/NureShpakDenys/apz-pzpi-22-3-shpak-denys/blob/main/Lab2/pzpi-22-3-shpak-denys-lab2/internal/core/domain/utils/analysis/analysis.go

  1  // Package analysis contains the functions to analyze the data of the deliveries
  2  // and predict the delivery speed
  3  package analysis // import "wayra/internal/core/domain/utils/analysis"
  4  
  5  import (
  6  	"fmt"
  7  	"wayra/internal/core/domain/models"
  8  	utilsMath "wayra/internal/core/domain/utils/math"
  9  )
 10  
 11  // DeliveryMetrics is a struct that contains the metrics of a delivery
 12  type DeliveryMetrics struct {
 13  	Temperature float64 // Temperature in Celsius
 14  	Humidity    float64 // Humidity in percentage
 15  	WindSpeed   float64 // Wind speed in m/s
 16  	TotalWeight float64 // Total weight in kg
 17  
 18  	DeliverySpeed float64 // Delivery speed in km/h
 19  }
 20  
 21  // PredictData is a struct that contains the data to predict the delivery speed
 22  type PredictData struct {
 23  	Distance float64 // Distance in km
 24  	Speed    float64 // Speed in km/h
 25  	Time     float64 // Time in hours
 26  }
 27  
 28  // PredictedData is a struct that contains the predicted data
 29  // data: the predicted data
 30  // return: the predicted data
 31  func LinearRegression(data []DeliveryMetrics) []float64 {
 32  	n := len(data)
 33  
 34  	// X
 35  	temperature := make([]float64, n)
 36  	humidity := make([]float64, n)
 37  	windSpeed := make([]float64, n)
 38  	totalWeight := make([]float64, n)
 39  
 40  	// Y
 41  	deliverySpeed := make([]float64, n)
 42  
 43  	for i, metrics := range data {
 44  		temperature[i] = metrics.Temperature
 45  		humidity[i] = metrics.Humidity
 46  		windSpeed[i] = metrics.WindSpeed
 47  		totalWeight[i] = metrics.TotalWeight
 48  
 49  		deliverySpeed[i] = metrics.DeliverySpeed
 50  	}
 51  
 52  	// X^2
 53  	temperatureSquared := utilsMath.Square(temperature)
 54  	humiditySquared := utilsMath.Square(humidity)
 55  	windSpeedSquared := utilsMath.Square(windSpeed)
 56  	totalWeightSquared := utilsMath.Square(totalWeight)
 57  	fmt.Printf("totalWeightSquared: %v\n", totalWeightSquared)
 58  
 59  	// Y^2
 60  	deliverySpeedSquared := utilsMath.Square(deliverySpeed)
 61  
 62  	// XY
 63  	temperatureDeliverySpeed := utilsMath.Multiply(temperature, deliverySpeed)
 64  	humidityDeliverySpeed := utilsMath.Multiply(humidity, deliverySpeed)
 65  	windSpeedDeliverySpeed := utilsMath.Multiply(windSpeed, deliverySpeed)
 66  	totalWeightDeliverySpeed := utilsMath.Multiply(totalWeight, deliverySpeed)
 67  	fmt.Printf("totalWeightDeliverySpeed: %v\n", totalWeightDeliverySpeed)
 68  
 69  	// X sum
 70  	sumTemperature := utilsMath.Sum(temperature)
 71  	sumHumidity := utilsMath.Sum(humidity)
 72  	sumWindSpeed := utilsMath.Sum(windSpeed)
 73  	sumTotalWeight := utilsMath.Sum(totalWeight)
 74  	fmt.Printf("sumTotalWeight: %v\n", sumTotalWeight)
 75  
 76  	// Y sum
 77  	sumDeliverySpeed := utilsMath.Sum(deliverySpeed)
 78  
 79  	// X^2 sum
 80  	sumTemperatureSquared := utilsMath.Sum(temperatureSquared)
 81  	sumHumiditySquared := utilsMath.Sum(humiditySquared)
 82  	sumWindSpeedSquared := utilsMath.Sum(windSpeedSquared)
 83  	sumTotalWeightSquared := utilsMath.Sum(totalWeightSquared)
 84  	fmt.Printf("sumTotalWeightSquared: %v\n", sumTotalWeightSquared)
 85  
 86  	// Y^2 sum
 87  	_ = utilsMath.Sum(deliverySpeedSquared)
 88  
 89  	// XY sum
 90  	sumTemperatureDeliverySpeed := utilsMath.Sum(temperatureDeliverySpeed)
 91  	sumHumidityDeliverySpeed := utilsMath.Sum(humidityDeliverySpeed)
 92  	sumWindSpeedDeliverySpeed := utilsMath.Sum(windSpeedDeliverySpeed)
 93  	sumTotalWeightDeliverySpeed := utilsMath.Sum(totalWeightDeliverySpeed)
 94  	fmt.Printf("sumTotalWeightDeliverySpeed: %v\n", sumTotalWeightDeliverySpeed)
 95  
 96  	// AvgX
 97  	avgTemperature := utilsMath.Mean(temperature)
 98  	avgHumidity := utilsMath.Mean(humidity)
 99  	avgWindSpeed := utilsMath.Mean(windSpeed)
100  	avgTotalWeight := utilsMath.Mean(totalWeight)
101  	fmt.Printf("avgTotalWeight: %v\n", avgTotalWeight)
102  
103  	// AvgY
104  	avgDeliverySpeed := utilsMath.Mean(deliverySpeed)
105  
106  	// Betas
107  	betaTemperature := CalculateBeta(sumTemperature, sumDeliverySpeed, sumTemperatureDeliverySpeed, sumTemperatureSquared, n)
108  	betaHumidity := CalculateBeta(sumHumidity, sumDeliverySpeed, sumHumidityDeliverySpeed, sumHumiditySquared, n)
109  	betaWindSpeed := CalculateBeta(sumWindSpeed, sumDeliverySpeed, sumWindSpeedDeliverySpeed, sumWindSpeedSquared, n)
110  	betaTotalWeight := CalculateBeta(sumTotalWeight, sumDeliverySpeed, sumTotalWeightDeliverySpeed, sumTotalWeightSquared, n)
111  
112  	fmt.Printf("Beta Total Weight: %f\n", betaTotalWeight)
113  
114  	// Free term
115  	beta0 := avgDeliverySpeed - betaTemperature*avgTemperature - betaHumidity*avgHumidity - betaWindSpeed*avgWindSpeed - betaTotalWeight*avgTotalWeight
116  
117  	// Calculate errors
118  	temperatureErrors := make([]float64, n)
119  	humidityErrors := make([]float64, n)
120  	windSpeedErrors := make([]float64, n)
121  	totalWeightErrors := make([]float64, n)
122  
123  	for i := 0; i < n; i++ {
124  		temperatureErrors[i] = deliverySpeed[i] - beta0 - betaTemperature*temperature[i] - betaHumidity*humidity[i] - betaWindSpeed*windSpeed[i]
125  		humidityErrors[i] = deliverySpeed[i] - beta0 - betaTemperature*temperature[i] - betaHumidity*humidity[i] - betaWindSpeed*windSpeed[i]
126  		windSpeedErrors[i] = deliverySpeed[i] - beta0 - betaTemperature*temperature[i] - betaHumidity*humidity[i] - betaWindSpeed*windSpeed[i]
127  		totalWeightErrors[i] = deliverySpeed[i] - beta0 - betaTemperature*temperature[i] - betaHumidity*humidity[i] - betaWindSpeed*windSpeed[i]
128  	}
129  
130  	// Calculate average error
131  	avgTemperatureError := utilsMath.Mean(temperatureErrors)
132  	avgHumidityError := utilsMath.Mean(humidityErrors)
133  	avgWindSpeedError := utilsMath.Mean(windSpeedErrors)
134  	avgTotalWeightError := utilsMath.Mean(totalWeightErrors)
135  
136  	error := avgTemperatureError + avgHumidityError + avgWindSpeedError + avgTotalWeightError
137  
138  	return []float64{beta0, betaTemperature, betaHumidity, betaWindSpeed, betaTotalWeight, error}
139  }
140  
141  // CalculateBeta calculates the beta value of regression
142  // sumX: sum of the X values
143  // sumY: sum of the Y values
144  // sumXY: sum of the X*Y values
145  // sumXSquared: sum of the X^2 values
146  // n: number of elements
147  // return: the beta value
148  func CalculateBeta(sumX, sumY, sumXY, sumXSquared float64, n int) float64 {
149  	if sumX == 0 && sumXSquared == 0 {
150  		return 0
151  	}
152  
153  	return (sumX*sumY - float64(n)*sumXY) / (sumX*sumX - float64(n)*sumXSquared)
154  }
155  
156  // Predict predicts the delivery speed
157  // coeffs: the coefficients of the regression
158  // input: the input data
159  // totalWeight: the total weight of the delivery
160  // return: the predicted delivery speed
161  func Predict(coeffs []float64, input models.SensorData, totalWeight float64) float64 {
162  	features := []float64{
163  		input.Temperature,
164  		input.Humidity,
165  		input.WindSpeed,
166  		totalWeight,
167  	}
168  
169  	result := coeffs[0]
170  	for i := 0; i < len(features); i++ {
171  		result += coeffs[i+1] * features[i]
172  	}
173  
174  	result += coeffs[len(coeffs)-1]
175  
176  	return result
177  }





В.3 Адміністрування бізнес-логіки системи. Резервне копіювання даних, стан бази даних, оптимізація бази даних. 

GitHub репозиторій: https://github.com/NureShpakDenys/apz-pzpi-22-3-shpak-denys/blob/main/Lab2/pzpi-22-3-shpak-denys-lab2/internal/adapter/httpserver/handlers/admin/db_admin.go

  1  package admin
  2  
  3  import (
  4  	"context"
  5  	"net/http"
  6  	"wayra/internal/adapter/httpserver/handlers"
  7  
  8  	"github.com/gin-gonic/gin"
  9  )
 10  
 11  // BackupDatabaseRequest is the request for the BackupDatabase endpoint
 12  type BackupDatabaseRequest struct {
 13  	// Backup path is the path where the backup will be stored
 14  	BackupPath string `json:"backup_path"`
 15  }
 16  
 17  // BackupDatabase godoc
 18  // @Summary Backup the database
 19  // @Description Backup the database in CSV format per table
 20  // @Tags admin
 21  // @Accept json
 22  // @Produce json
 23  // @Param BackupDatabaseRequest body BackupDatabaseRequest true "Backup directory path"
 24  // @Security     BearerAuth
 25  // @Router /admin/backup [post]
 26  func (ah *AdminHandler) BackupDatabase(c *gin.Context) {
 27  	var req BackupDatabaseRequest
 28  	if err := c.ShouldBindJSON(&req); err != nil {
 29  		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
 30  		return
 31  	}
 32  
 33  	userID, err := handlers.GetUserIDFromToken(c)
 34  	if err != nil {
 35  		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
 36  		return
 37  	}
 38  
 39  	user, err := ah.userService.GetByID(context.Background(), *userID)
 40  	if err != nil {
 41  		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
 42  		return
 43  	}
 44  
 45  	if user.Role.Name != "db_admin" {
 46  		c.JSON(http.StatusForbidden, gin.H{"error": "Access denied"})
 47  		return
 48  	}
 49  
 50  	if err := ah.AdminService.BackupDatabase(c.Request.Context(), *userID, req.BackupPath); err != nil {
 51  		c.JSON(http.StatusInternalServerError, gin.H{"error": "Backup failed: " + err.Error()})
 52  		return
 53  	}
 54  
 55  	c.JSON(http.StatusOK, gin.H{"message": "Backup created successfully"})
 56  }
 57  
 58  // RestoreDatabaseRequest is the request for the RestoreDatabase endpoint
 59  type RestoreDatabaseRequest struct {
 60  	// Backup path is the path where the backup is stored
 61  	BackupPath string `json:"backup_path"`
 62  }
 63  
 64  // RestoreDatabase godoc
 65  // @Summary Restore the database from backup
 66  // @Description Restore the database from encrypted backup files
 67  // @Tags admin
 68  // @Accept json
 69  // @Produce json
 70  // @Param RestoreDatabaseRequest body RestoreDatabaseRequest true "Backup directory path"
 71  // @Security     BearerAuth
 72  // @Success 200 {string} string "Database restored"
 73  // @Router /admin/restore [post]
 74  func (ah *AdminHandler) RestoreDatabase(c *gin.Context) {
 75  	var req RestoreDatabaseRequest
 76  	if err := c.ShouldBindJSON(&req); err != nil {
 77  		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
 78  		return
 79  	}
 80  
 81  	userID, err := handlers.GetUserIDFromToken(c)
 82  	if err != nil {
 83  		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
 84  		return
 85  	}
 86  
 87  	user, err := ah.userService.GetByID(context.Background(), *userID)
 88  	if err != nil {
 89  		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
 90  		return
 91  	}
 92  
 93  	if user.Role.Name != "db_admin" {
 94  		c.JSON(http.StatusForbidden, gin.H{"error": "Access denied"})
 95  		return
 96  	}
 97  
 98  	if err := ah.AdminService.RestoreDatabase(c.Request.Context(), *userID, req.BackupPath); err != nil {
 99  		c.JSON(http.StatusInternalServerError, gin.H{"error": "Restore failed: " + err.Error()})
100  		return
101  	}
102  
103  	c.JSON(http.StatusOK, gin.H{"message": "Database restored successfully"})
104  }
105  
106  // GetDBStatus godoc
107  // @Summary Get database status
108  // @Description Get database status
109  // @Tags admin
110  // @Accept json
111  // @Produce json
112  // @Security     BearerAuth
113  // @Router /admin/db-status [get]
114  func (ah *AdminHandler) GetDBStatus(c *gin.Context) {
115  	userID, err := handlers.GetUserIDFromToken(c)
116  	if err != nil {
117  		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
118  		return
119  	}
120  
121  	currentUser, err := ah.userService.GetByID(context.Background(), *userID)
122  	if err != nil || currentUser.Role.Name != "db_admin" {
123  		c.JSON(http.StatusForbidden, gin.H{"error": "Access denied"})
124  		return
125  	}
126  
127  	dbStatus, _ := ah.AdminService.GetDBStatus(context.Background())
128  
129  	c.JSON(http.StatusOK, dbStatus)
130  }
131  
132  // OptimizeDatabase godoc
133  // @Summary Optimize database
134  // @Description Optimize database
135  // @Tags admin
136  // @Accept json
137  // @Produce json
138  // @Security     BearerAuth
139  // @Router /admin/optimize [post]
140  func (ah *AdminHandler) OptimizeDatabase(c *gin.Context) {
141  	userID, err := handlers.GetUserIDFromToken(c)
142  	if err != nil {
143  		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
144  		return
145  	}
146  
147  	currentUser, err := ah.userService.GetByID(context.Background(), *userID)
148  	if err != nil || currentUser.Role.Name != "db_admin" {
149  		c.JSON(http.StatusForbidden, gin.H{"error": "Access denied"})
150  		return
151  	}
152  
153  	if err := ah.AdminService.OptimizeDatabase(context.Background()); err != nil {
154  		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to optimize database"})
155  		return
156  	}
157  
158  	c.JSON(http.StatusOK, gin.H{"message": "Database optimized successfully"})
159  }

В.4 Адміністрування бізнес-логіки системи. Стан системи, управління її конфігураціями, читання та управління журналом логів.

GitHub репозиторій: https://github.com/NureShpakDenys/apz-pzpi-22-3-shpak-denys/blob/main/Lab2/pzpi-22-3-shpak-denys-lab2/internal/adapter/httpserver/handlers/admin/system_admin.go
  
  1  package admin
  2  
  3  import (
  4  	"context"
  5  	"net/http"
  6  	"time"
  7  	"wayra/internal/adapter/httpserver/handlers"
  8  	"wayra/internal/core/domain/models"
  9  
 10  	"github.com/gin-gonic/gin"
 11  )
 12  
 13  // HealthCheckHandler godoc
 14  // @Summary Health check
 15  // @Description Health check endpoint
 16  // @Security     BearerAuth
 17  // @Tags admin
 18  // @Accept json
 19  // @Produce json
 20  // @Router /admin/health [get]
 21  func (h *AdminHandler) HealthCheckHandler(c *gin.Context) {
 22  	userID, err := handlers.GetUserIDFromToken(c)
 23  	if err != nil {
 24  		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
 25  		return
 26  	}
 27  
 28  	currentUser, err := h.userService.GetByID(context.Background(), *userID)
 29  	if err != nil || currentUser.Role.Name != "system_admin" {
 30  		c.JSON(http.StatusForbidden, gin.H{"error": "Access denied"})
 31  		return
 32  	}
 33  
 34  	dbStatus := "ok"
 35  	if err := h.db.Raw("SELECT 1").Error; err != nil {
 36  		dbStatus = "error"
 37  	}
 38  
 39  	c.JSON(http.StatusOK, gin.H{
 40  		"server_time": time.Now(),
 41  		"db_status":   dbStatus,
 42  		"uptime":      time.Since(h.serverStartTime).String(),
 43  	})
 44  }
 45  
 46  // GetServerLogs godoc
 47  // @Summary Get server logs
 48  // @Description Get server logs
 49  // @Tags admin
 50  // @Accept json
 51  // @Produce json
 52  // @Security     BearerAuth
 53  // @Router /admin/logs [get]
 54  func (ah *AdminHandler) GetServerLogs(c *gin.Context) {
 55  	userID, err := handlers.GetUserIDFromToken(c)
 56  	if err != nil {
 57  		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
 58  		return
 59  	}
 60  
 61  	currentUser, err := ah.userService.GetByID(context.Background(), *userID)
 62  	if err != nil || currentUser.Role.Name != "system_admin" {
 63  		c.JSON(http.StatusForbidden, gin.H{"error": "Access denied"})
 64  		return
 65  	}
 66  
 67  	logs, err := ah.LogService.Where(context.Background(), &models.Log{})
 68  	if err != nil {
 69  		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to retrieve logs"})
 70  		return
 71  	}
 72  
 73  	c.JSON(http.StatusOK, logs)
 74  }
 75  
 76  // GetSystemConfigs godoc
 77  // @Summary Get system configs
 78  // @Description Get system configs
 79  // @Tags admin
 80  // @Accept json
 81  // @Produce json
 82  // @Security     BearerAuth
 83  // @Router /admin/system-configs [get]
 84  func (ah *AdminHandler) GetSystemConfigs(c *gin.Context) {
 85  	userID, err := handlers.GetUserIDFromToken(c)
 86  	if err != nil {
 87  		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
 88  		return
 89  	}
 90  
 91  	currentUser, err := ah.userService.GetByID(context.Background(), *userID)
 92  	if err != nil || currentUser.Role.Name != "system_admin" {
 93  		c.JSON(http.StatusForbidden, gin.H{"error": "Access denied"})
 94  		return
 95  	}
 96  
 97  	configs := ah.AdminService.GetSystemConfig()
 98  	c.JSON(http.StatusOK, configs)
 99  }
100  
101  type UpdateSystemConfigsRequest struct {
102  	TimeOutSec int `json:"timeout_sec"`
103  	TokenTTL   int `json:"token_ttl"`
104  }
105  
106  // UpdateSystemConfigs godoc
107  // @Summary Update system configs
108  // @Description Update system configs
109  // @Tags admin
110  // @Accept json
111  // @Produce json
112  // @Param UpdateSystemConfigsRequest body UpdateSystemConfigsRequest true "UpdateSystemConfigsRequest"
113  // @Security     BearerAuth
114  // @Router /admin/system-configs [put]
115  func (ah *AdminHandler) UpdateSystemConfigs(c *gin.Context) {
116  	var req UpdateSystemConfigsRequest
117  	if err := c.ShouldBindJSON(&req); err != nil {
118  		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
119  		return
120  	}
121  
122  	userID, err := handlers.GetUserIDFromToken(c)
123  	if err != nil {
124  		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
125  		return
126  	}
127  
128  	currentUser, err := ah.userService.GetByID(context.Background(), *userID)
129  	if err != nil || currentUser.Role.Name != "system_admin" {
130  		c.JSON(http.StatusForbidden, gin.H{"error": "Access denied"})
131  		return
132  	}
133  
134  	if err := ah.AdminService.UpdateSystemConfig(req.TimeOutSec, req.TokenTTL); err != nil {
135  		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update system configs"})
136  		return
137  	}
138  
139  	configs := ah.AdminService.GetSystemConfig()
140  
141  	c.JSON(http.StatusOK, configs)
142  }
143  
144  type ClearLogsRequest struct {
145  	Days int `json:"days"`
146  }
147  
148  // ClearLogs godoc
149  // @Summary Clear logs
150  // @Description Clear logs older than a specified number of days
151  // @Tags admin
152  // @Accept json
153  // @Produce json
154  // @Param ClearLogsRequest body ClearLogsRequest true "ClearLogsRequest"
155  // @Security     BearerAuth
156  // @Router /admin/clear-logs [post]
157  func (ah *AdminHandler) ClearLogs(c *gin.Context) {
158  	var req ClearLogsRequest
159  	if err := c.ShouldBindJSON(&req); err != nil {
160  		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
161  		return
162  	}
163  
164  	userID, err := handlers.GetUserIDFromToken(c)
165  	if err != nil {
166  		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
167  		return
168  	}
169  
170  	currentUser, err := ah.userService.GetByID(context.Background(), *userID)
171  	if err != nil || currentUser.Role.Name != "system_admin" {
172  		c.JSON(http.StatusForbidden, gin.H{"error": "Access denied"})
173  		return
174  	}
175  
176  	if err := ah.AdminService.ClearOldLogs(context.Background(), req.Days); err != nil {
177  		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to clear logs"})
178  		return
179  	}
180  
181  	c.JSON(http.StatusOK, gin.H{"message": "Logs cleared successfully"})
182  }

В.5 Адміністрування бізнес-логіки системи. Зміна ролей користувачів.

GitHub репозиторій: https://github.com/NureShpakDenys/apz-pzpi-22-3-shpak-denys/blob/main/Lab2/pzpi-22-3-shpak-denys-lab2/internal/adapter/httpserver/handlers/admin/admin_handler.go

 1  package admin // import "wayra/internal/adapter/httpserver/handlers/admin"
 2  
 3  import (
 4  	"context"
 5  	"fmt"
 6  	"net/http"
 7  	"time"
 8  	"wayra/internal/adapter/config"
 9  	"wayra/internal/adapter/httpserver/handlers"
10  	"wayra/internal/core/domain/models"
11  	"wayra/internal/core/port/services"
12  
13  	"github.com/gin-gonic/gin"
14  	"gorm.io/gorm"
15  )
16  
17  // AdminHandler is a handler for admin endpoints
18  type AdminHandler struct {
19  	dbPassword      string                // Password for the database
20  	userService     services.UserService  // Service for user operations
21  	encryptionKey   []byte                // Key for encryption
22  	db              *gorm.DB              //db for health check
23  	serverStartTime time.Time             // Server start time for uptime calculation
24  	LogService      services.LogService   // Service for logging actions
25  	AdminService    services.AdminService // Service for admin operations
26  }
27  
28  // NewAdminHandler creates a new AdminHandler
29  // dbPassword: Password for the database
30  // userService: Service for user operations
31  // Returns: A new AdminHandler
32  func NewAdminHandler(
33  	userService services.UserService,
34  	cfg *config.Config,
35  	db *gorm.DB,
36  	logService services.LogService,
37  	adminService services.AdminService,
38  ) *AdminHandler {
39  	return &AdminHandler{
40  		dbPassword:      cfg.DBPassword,
41  		userService:     userService,
42  		encryptionKey:   []byte(cfg.EncryptionKey),
43  		db:              db,
44  		serverStartTime: time.Now(),
45  		LogService:      logService,
46  		AdminService:    adminService,
47  	}
48  }
49  
50  type UpdateUserRoleRequest struct {
51  	UserID int64 `json:"userId"`
52  	RoleID uint  `json:"roleId"`
53  }
54  
55  // UpdateUserRole godoc
56  // @Summary Update user role
57  // @Description Update user role
58  // @Tags admin
59  // @Accept json
60  // @Produce json
61  // @Param UpdateUserRoleRequest body UpdateUserRoleRequest true "UpdateUserRoleRequest"
62  // @Security     BearerAuth
63  // @Router /admin/change-role [post]
64  func (ah *AdminHandler) UpdateUserRole(c *gin.Context) {
65  	var req UpdateUserRoleRequest
66  	if err := c.ShouldBindJSON(&req); err != nil {
67  		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
68  		return
69  	}
70  
71  	userID, err := handlers.GetUserIDFromToken(c)
72  	if err != nil {
73  		c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
74  		return
75  	}
76  
77  	currentUser, err := ah.userService.GetByID(context.Background(), *userID)
78  	if err != nil || currentUser.Role.Name != "admin" {
79  		c.JSON(http.StatusForbidden, gin.H{"error": "Access denied"})
80  		return
81  	}
82  
83  	if err := ah.userService.Update(context.Background(), &models.User{
84  		ID:     uint(req.UserID),
85  		RoleID: req.RoleID,
86  	}); err != nil {
87  		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
88  		ah.LogService.LogAction(userID, "update_user_role", "Failed to change user role: "+err.Error(), false)
89  		return
90  	}
91  
92  	ah.LogService.LogAction(userID, "update_user_role", fmt.Sprintf("User %d role changed to %d", req.UserID, req.RoleID), true)
93  	c.JSON(http.StatusOK, gin.H{"message": "User role updated"})
94  }

В.6 Адміністрування бізнес-логіки системи. Управління статусом користувачів у компанії.

GitHub репозиторій: https://github.com/NureShpakDenys/apz-pzpi-22-3-shpak-denys/blob/main/Lab2/pzpi-22-3-shpak-denys-lab2/internal/adapter/httpserver/handlers/company/company_user_management.go

  1  package company
  2  
  3  import (
  4  	"context"
  5  	"fmt"
  6  	"net/http"
  7  	"strconv"
  8  	"wayra/internal/adapter/httpserver/handlers"
  9  	"wayra/internal/core/domain/dtos"
 10  	"wayra/internal/core/domain/models"
 11  
 12  	dtoMapper "github.com/dranikpg/dto-mapper"
 13  	"github.com/gin-gonic/gin"
 14  )
 15  
 16  // AddUserToCompany godoc
 17  // @Summary      Add a user to a company
 18  // @Description  Adds a user to a company if the request is made by the company creator
 19  // @Tags         company
 20  // @Accept       json
 21  // @Produce      json
 22  // @Param        company_id path int true "Company ID"
 23  // @Param        userID body AddUserToCompanyRequest true "User ID to add"
 24  // @Security     BearerAuth
 25  // @Router       /company/{company_id}/add-user [post]
 26  func (h *CompanyHandler) AddUserToCompany(c *gin.Context) {
 27  	userID, err := handlers.GetUserIDFromToken(c)
 28  	if err != nil {
 29  		c.JSON(http.StatusForbidden, gin.H{"error": "you can not do this"})
 30  		h.logAction(c, "add_user_to_company", "Failed to add user to company: "+err.Error(), false)
 31  
 32  		return
 33  	}
 34  
 35  	user, err := h.UserService.GetByID(context.Background(), *userID)
 36  	if err != nil {
 37  		c.JSON(http.StatusForbidden, gin.H{"error": "you can not do this"})
 38  		h.logAction(c, "add_user_to_company", "Failed to add user to company: "+err.Error(), false)
 39  
 40  		return
 41  	}
 42  
 43  	if user.Role.Name != "admin" {
 44  		c.JSON(http.StatusForbidden, gin.H{"error": "you can not do this"})
 45  		h.logAction(c, "add_user_to_company", "Failed to add user to company: "+err.Error(), false)
 46  
 47  		return
 48  	}
 49  
 50  	var addUserToCompanyRequest AddUserToCompanyRequest
 51  
 52  	companyID, err := strconv.Atoi(c.Param("company_id"))
 53  	if err != nil {
 54  		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid company ID format"})
 55  		h.logAction(c, "add_user_to_company", "Failed to add user to company: "+err.Error(), false)
 56  
 57  		return
 58  	}
 59  
 60  	if err := c.ShouldBindJSON(&addUserToCompanyRequest); err != nil {
 61  		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input"})
 62  		h.logAction(c, "add_user_to_company", "Failed to add user to company: "+err.Error(), false)
 63  
 64  		return
 65  	}
 66  
 67  	userCompany := models.UserCompany{
 68  		UserID:    addUserToCompanyRequest.UserID,
 69  		CompanyID: uint(companyID),
 70  		Role:      string(addUserToCompanyRequest.Role),
 71  	}
 72  
 73  	if err := h.userCompanyService.Create(context.Background(), &userCompany); err != nil {
 74  		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
 75  		h.logAction(c, "add_user_to_company", "Failed to add user to company: "+err.Error(), false)
 76  
 77  		return
 78  	}
 79  
 80  	userCompanyDTO := &dtos.UserCompanyDTO{}
 81  
 82  	if err = dtoMapper.Map(userCompanyDTO, userCompany); err != nil {
 83  		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
 84  		h.logAction(c, "add_user_to_company", "Failed to add user to company: "+err.Error(), false)
 85  
 86  		return
 87  	}
 88  
 89  	h.logAction(c, "add_user_to_company", fmt.Sprintf("User %d added to company %d", addUserToCompanyRequest.UserID, companyID), true)
 90  	c.JSON(http.StatusOK, userCompanyDTO)
 91  }
 92  
 93  // UpdateUserInCompany godoc
 94  // @Summary      Update a user in a company
 95  // @Description  Updates a user in a company if the request is made by the company creator
 96  // @Tags         company
 97  // @Accept       json
 98  // @Produce      json
 99  // @Param        company_id path int true "Company ID"
100  // @Param        userID body UpdateUserInCompanyRequest true "User ID to update"
101  // @Security     BearerAuth
102  // @Router       /company/{company_id}/update-user [put]
103  func (h *CompanyHandler) UpdateUserInCompany(c *gin.Context) {
104  	var updateUserInCompanyRequest UpdateUserInCompanyRequest
105  
106  	companyID, err := strconv.Atoi(c.Param("company_id"))
107  	if err != nil {
108  		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid company ID format"})
109  		h.logAction(c, "update_user_in_company", "Failed to update user in company: "+err.Error(), false)
110  
111  		return
112  	}
113  
114  	if err := c.ShouldBindJSON(&updateUserInCompanyRequest); err != nil {
115  		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input"})
116  		h.logAction(c, "update_user_in_company", "Failed to update user in company: "+err.Error(), false)
117  
118  		return
119  	}
120  
121  	userCompanies, err := h.userCompanyService.Where(context.Background(), &models.UserCompany{
122  		UserID:    updateUserInCompanyRequest.UserID,
123  		CompanyID: uint(companyID),
124  	})
125  	if err != nil {
126  		c.JSON(http.StatusNotFound, gin.H{"error": "User not found in the company"})
127  		h.logAction(c, "update_user_in_company", "Failed to update user in company: "+err.Error(), false)
128  
129  		return
130  	}
131  
132  	userCompany := &userCompanies[0]
133  	if updateUserInCompanyRequest.Role != "" {
134  		userCompany.Role = updateUserInCompanyRequest.Role
135  	}
136  
137  	if err := h.userCompanyService.Update(context.Background(), userCompany); err != nil {
138  		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
139  		h.logAction(c, "update_user_in_company", "Failed to update user in company: "+err.Error(), false)
140  
141  		return
142  	}
143  
144  	userCompanyDTO := &dtos.UserCompanyDTO{}
145  
146  	if err = dtoMapper.Map(userCompanyDTO, userCompany); err != nil {
147  		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
148  		h.logAction(c, "update_user_in_company", "Failed to update user in company: "+err.Error(), false)
149  
150  		return
151  	}
152  
153  	h.logAction(c, "update_user_in_company", fmt.Sprintf("User %d updated in company %d", updateUserInCompanyRequest.UserID, companyID), true)
154  	c.JSON(http.StatusOK, userCompanyDTO)
155  }
156  
157  // RemoveUserFromCompany godoc
158  // @Summary      Remove a user from a company
159  // @Description  Removes a user from a company if the request is made by the company creator
160  // @Tags         company
161  // @Accept       json
162  // @Produce      json
163  // @Param        company_id path int true "Company ID"
164  // @Param        userID body RemoveUserFromCompanyRequest true "User ID to remove"
165  // @Security     BearerAuth
166  // @Router       /company/{company_id}/remove-user [delete]
167  func (h *CompanyHandler) RemoveUserFromCompany(c *gin.Context) {
168  	var removeUserFromCompanyRequest RemoveUserFromCompanyRequest
169  
170  	companyID, err := strconv.Atoi(c.Param("company_id"))
171  	if err != nil {
172  		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid company ID format"})
173  		h.logAction(c, "remove_user_from_company", "Failed to remove user from company: "+err.Error(), false)
174  
175  		return
176  	}
177  
178  	if err := c.ShouldBindJSON(&removeUserFromCompanyRequest); err != nil {
179  		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid input"})
180  		h.logAction(c, "remove_user_from_company", "Failed to remove user from company: "+err.Error(), false)
181  
182  		return
183  	}
184  
185  	userCompanies, err := h.userCompanyService.Where(context.Background(), &models.UserCompany{
186  		UserID:    removeUserFromCompanyRequest.UserID,
187  		CompanyID: uint(companyID),
188  	})
189  	if err != nil {
190  		c.JSON(http.StatusNotFound, gin.H{"error": "User not found in the company"})
191  		h.logAction(c, "remove_user_from_company", "Failed to remove user from company: "+err.Error(), false)
192  
193  		return
194  	}
195  
196  	userCompany := userCompanies[0]
197  
198  	if err := h.userCompanyService.Delete(context.Background(), userCompany.ID); err != nil {
199  		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
200  		return
201  	}
202  
203  	h.logAction(c, "remove_user_from_company", fmt.Sprintf("User %d removed from company %d", removeUserFromCompanyRequest.UserID, companyID), true)
204  	c.JSON(http.StatusOK, gin.H{"message": "User removed from company successfully"})
205  }
206  
207  // GetCompanies godoc
208  // @Summary      Get all companies
209  // @Description  Retrieves a list of all companies
210  // @Tags         company
211  // @Produce      json
212  // @Security     BearerAuth
213  // @Router       /company/ [get]
214  // @Success      200  {array}  dtos.CompanyDTO
215  func (h *CompanyHandler) GetCompanies(c *gin.Context) {
216  	var companies []models.Company
217  
218  	companies, err := h.companyService.GetAll()
219  	if err != nil {
220  		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
221  		return
222  	}
223  
224  	companiesDTO := make([]dtos.CompanyDTO, len(companies))
225  	for i, company := range companies {
226  		if err = dtoMapper.Map(&companiesDTO[i], company); err != nil {
227  			c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
228  			return
229  		}
230  	}
231  	c.JSON(http.StatusOK, companiesDTO)
232  }
233  
234  func (h *CompanyHandler) logAction(c *gin.Context, actionType, description string, success bool) {
235  	userID, err := handlers.GetUserIDFromToken(c)
236  	if err != nil {
237  		userID = nil
238  	}
239  	h.LogService.LogAction(userID, actionType, description, success)
240  }

В.7 Резервне копіювання користувацьких даних

GitHub репозиторій: https://github.com/NureShpakDenys/apz-pzpi-22-3-shpak-denys/blob/main/Lab2/pzpi-22-3-shpak-denys-lab2/internal/core/service/admin_service.go

  1  // internal/port/services/admin_service.go
  2  package service
  3  
  4  import (
  5  	"context"
  6  	"crypto/aes"
  7  	"crypto/cipher"
  8  	"crypto/rand"
  9  	"errors"
 10  	"fmt"
 11  	"io"
 12  	"io/ioutil"
 13  	"os"
 14  	"os/exec"
 15  	"time"
 16  
 17  	"wayra/internal/adapter/config"
 18  	"wayra/internal/core/port/services"
 19  
 20  	"gorm.io/gorm"
 21  )
 22  
 23  type AdminService struct {
 24  	cfg           *config.Config
 25  	db            *gorm.DB
 26  	EncryptionKey []byte
 27  }
 28  
 29  func NewAdminService(cfg *config.Config, db *gorm.DB, encKey []byte) services.AdminService {
 30  	return &AdminService{cfg: cfg, db: db, EncryptionKey: encKey}
 31  }
 32  
 33  var backupTables = []string{
 34  	"roles",
 35  	"users",
 36  	"companies",
 37  	"routes",
 38  	"deliveries",
 39  	"product_categories",
 40  	"products",
 41  	"waypoints",
 42  	"sensor_data",
 43  	"user_companies",
 44  }
 45  
 46  func (s *AdminService) BackupDatabase(ctx context.Context, userID uint, backupPath string) error {
 47  	if err := os.MkdirAll(backupPath, 0755); err != nil {
 48  		return fmt.Errorf("failed to create backup directory: %w", err)
 49  	}
 50  
 51  	for _, table := range backupTables {
 52  		filePath := fmt.Sprintf("%s/%s.csv", backupPath, table)
 53  
 54  		if err := s.exportTable(table, filePath); err != nil {
 55  			return fmt.Errorf("error exporting table %s: %w", table, err)
 56  		}
 57  
 58  		if err := encryptFile(filePath, s.EncryptionKey); err != nil {
 59  			return fmt.Errorf("error encrypting file %s: %w", filePath, err)
 60  		}
 61  	}
 62  
 63  	s.db.Exec("INSERT INTO backup_logs (backup_time) VALUES (now())")
 64  	return nil
 65  }
 66  
 67  func (s *AdminService) RestoreDatabase(ctx context.Context, userID uint, backupPath string) error {
 68  	tempPath := fmt.Sprintf("%s/temp", backupPath)
 69  	if err := os.MkdirAll(tempPath, 0755); err != nil {
 70  		return fmt.Errorf("failed to create temp directory: %w", err)
 71  	}
 72  	defer os.RemoveAll(tempPath)
 73  
 74  	for _, table := range backupTables {
 75  		encPath := fmt.Sprintf("%s/%s.csv", backupPath, table)
 76  		tmpPath := fmt.Sprintf("%s/%s.csv", tempPath, table)
 77  
 78  		if err := decryptFileTo(encPath, tmpPath, s.EncryptionKey); err != nil {
 79  			return fmt.Errorf("error decrypting file %s: %w", encPath, err)
 80  		}
 81  
 82  		if err := s.truncateTable(table); err != nil {
 83  			return fmt.Errorf("error truncating table %s: %w", table, err)
 84  		}
 85  
 86  		if err := s.importTable(table, tmpPath); err != nil {
 87  			return fmt.Errorf("error importing table %s: %w", table, err)
 88  		}
 89  	}
 90  
 91  	return nil
 92  }
 93  
 94  func (s *AdminService) GetSystemConfig() map[string]interface{} {
 95  	return map[string]interface{}{
 96  		"http_timeout_seconds":  int(s.cfg.Http.Timeout.Seconds()),
 97  		"auth_token_ttl_hours":  int(s.cfg.AuthConfig.TokenExpiry.Hours()),
 98  		"encryption_key_exists": s.cfg.EncryptionKey != "",
 99  	}
100  }
101  
102  func (s *AdminService) UpdateSystemConfig(timeoutSeconds int, tokenTTLHrs int) error {
103  	if timeoutSeconds <= 0 || tokenTTLHrs <= 0 {
104  		return errors.New("invalid timeout or TTL")
105  	}
106  
107  	s.cfg.Http.Timeout = time.Duration(timeoutSeconds) * time.Second
108  	s.cfg.AuthConfig.TokenExpiry = time.Duration(tokenTTLHrs) * time.Hour
109  	return nil
110  }
111  
112  func (s *AdminService) GetDBStatus(ctx context.Context) (*services.DBStatus, error) {
113  	var size float64
114  	err := s.db.Raw(`
115  		SELECT pg_database_size(current_database()) / 1024 / 1024 AS size_mb
116  	`).Scan(&size).Error
117  	if err != nil {
118  		return nil, err
119  	}
120  
121  	var activeConnections int
122  	err = s.db.Raw(`
123  		SELECT count(*) FROM pg_stat_activity
124  	`).Scan(&activeConnections).Error
125  	if err != nil {
126  		return nil, err
127  	}
128  
129  	var lastBackup time.Time
130  	err = s.db.Raw(`
131  		 SELECT backup_time FROM backup_logs ORDER BY backup_time DESC LIMIT 1
132  	`).Scan(&lastBackup).Error
133  	if err != nil || lastBackup.IsZero() {
134  		lastBackup = time.Time{}
135  	}
136  	return &services.DBStatus{
137  		DatabaseSizeMB:    size,
138  		ActiveConnections: activeConnections,
139  		LastBackupTime:    lastBackup,
140  	}, nil
141  }
142  
143  func (s *AdminService) OptimizeDatabase(ctx context.Context) error {
144  	return s.db.Exec("VACUUM FULL").Error
145  }
146  
147  func (s *AdminService) ClearOldLogs(ctx context.Context, olderThanDays int) error {
148  	if olderThanDays <= 0 {
149  		return errors.New("invalid number of days")
150  	}
151  	cutoff := time.Now().AddDate(0, 0, -olderThanDays)
152  	return s.db.Exec("DELETE FROM logs WHERE created_at < ?", cutoff).Error
153  }
154  
155  func encryptFile(filename string, key []byte) error {
156  	plaintext, err := ioutil.ReadFile(filename)
157  	if err != nil {
158  		return err
159  	}
160  
161  	block, err := aes.NewCipher(key)
162  	if err != nil {
163  		return err
164  	}
165  
166  	aesGCM, err := cipher.NewGCM(block)
167  	if err != nil {
168  		return err
169  	}
170  
171  	nonce := make([]byte, aesGCM.NonceSize())
172  	if _, err = io.ReadFull(rand.Reader, nonce); err != nil {
173  		return err
174  	}
175  
176  	ciphertext := aesGCM.Seal(nonce, nonce, plaintext, nil)
177  	return ioutil.WriteFile(filename, ciphertext, 0644)
178  }
179  
180  func decryptFileTo(encryptedPath, decryptedPath string, key []byte) error {
181  	ciphertext, err := ioutil.ReadFile(encryptedPath)
182  	if err != nil {
183  		return err
184  	}
185  
186  	block, err := aes.NewCipher(key)
187  	if err != nil {
188  		return err
189  	}
190  
191  	aesGCM, err := cipher.NewGCM(block)
192  	if err != nil {
193  		return err
194  	}
195  
196  	nonceSize := aesGCM.NonceSize()
197  	if len(ciphertext) < nonceSize {
198  		return fmt.Errorf("ciphertext too short")
199  	}
200  
201  	nonce, ciphertext := ciphertext[:nonceSize], ciphertext[nonceSize:]
202  	plaintext, err := aesGCM.Open(nil, nonce, ciphertext, nil)
203  	if err != nil {
204  		return err
205  	}
206  
207  	return ioutil.WriteFile(decryptedPath, plaintext, 0644)
208  }
209  
210  func (s *AdminService) exportTable(table, filePath string) error {
211  	cmd := exec.Command(
212  		"psql",
213  		"-U", "postgres",
214  		"-d", "Wayra",
215  		"-h", "localhost",
216  		"-p", "5432",
217  		"-c", fmt.Sprintf(`\COPY %s TO '%s' WITH CSV HEADER`, table, filePath),
218  	)
219  	cmd.Env = append(os.Environ(), "PGPASSWORD="+s.cfg.DBPassword)
220  	return cmd.Run()
221  }
222  
223  func (s *AdminService) truncateTable(table string) error {
224  	cmd := exec.Command(
225  		"psql",
226  		"-U", "postgres",
227  		"-d", "Wayra",
228  		"-h", "localhost",
229  		"-p", "5432",
230  		"-c", fmt.Sprintf(`TRUNCATE TABLE %s RESTART IDENTITY CASCADE;`, table),
231  	)
232  	cmd.Env = append(os.Environ(), "PGPASSWORD="+s.cfg.DBPassword)
233  	_, err := cmd.CombinedOutput()
234  	return err
235  }
236  
237  func (s *AdminService) importTable(table, filePath string) error {
238  	cmd := exec.Command(
239  		"psql",
240  		"-U", "postgres",
241  		"-d", "Wayra",
242  		"-h", "localhost",
243  		"-p", "5432",
244  		"-c", fmt.Sprintf(`\COPY %s FROM '%s' WITH CSV HEADER`, table, filePath),
245  	)
246  	cmd.Env = append(os.Environ(), "PGPASSWORD="+s.cfg.DBPassword)
247  	_, err := cmd.CombinedOutput()
248  	return err
249  }


